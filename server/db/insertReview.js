// db/insertReview.js
const pool = require('../config/db');

async function getOrCreateHotelId(hotel_name, location = 'Unknown', chain_id = 1) {
  try {
    // Validate inputs
    if (!hotel_name || typeof hotel_name !== 'string') {
      throw new Error(`Invalid hotel_name: ${hotel_name}`);
    }
    if (typeof location !== 'string') {
      throw new Error(`Invalid location: ${location}`);
    }
    if (!Number.isInteger(chain_id)) {
      throw new Error(`Invalid chain_id: ${chain_id}`);
    }

    // Normalize hotel_name for consistency (e.g., trim, lowercase)
    const normalized_name = hotel_name.trim().toLowerCase();
    console.log(`üîç Checking for hotel: ${hotel_name} (normalized: ${normalized_name})`);

    // Check if hotel exists
    const selectQuery = `
      SELECT hotel_id FROM hotels WHERE LOWER(name) = $1;
    `;
    const selectResult = await pool.query(selectQuery, [normalized_name]);

    if (selectResult.rows.length > 0) {
      console.log(`‚úÖ Found hotel: ${hotel_name} with hotel_id: ${selectResult.rows[0].hotel_id}`);
      return selectResult.rows[0].hotel_id;
    }

    // Insert new hotel
    const insertQuery = `
      INSERT INTO hotels (name, location, chain_id)
      VALUES ($1, $2, $3)
      RETURNING hotel_id;
    `;
    console.log(`üìù Executing insert query with params: name=${hotel_name}, location=${location}, chain_id=${chain_id}`);
    const insertResult = await pool.query(insertQuery, [hotel_name, location, chain_id]);
    const newHotelId = insertResult.rows[0].hotel_id;
    console.log(`üè® Created new hotel: ${hotel_name} (ID: ${newHotelId}, Location: ${location}, Chain ID: ${chain_id})`);
    return newHotelId;
  } catch (err) {
    console.error(`‚ùå Failed to get or create hotel_id for ${hotel_name}:`, err);
    throw err;
  }
}

async function insertReview(review) {
  const query = `
    INSERT INTO guest_reviews (
      created_at,
      reviewer_name,
      reviewer_country,
      rating,
      sentiment_score,
      review_headline,
      review_positive,
      review_negative,
      hotel_response,
      response_quality_score,
      hotel_id,
      source_id,
      review_text,
      is_genius,
      reservation_id,
      reply_last_modified,
      room_type,
      num_of_nights,
      composition,
      lang,
      response_id
    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21)
    ON CONFLICT (reviewer_name, created_at, hotel_id) DO UPDATE
    SET
      reviewer_country = EXCLUDED.reviewer_country,
      rating = EXCLUDED.rating,
      sentiment_score = EXCLUDED.sentiment_score,
      review_headline = EXCLUDED.review_headline,
      review_positive = EXCLUDED.review_positive,
      review_negative = EXCLUDED.review_negative,
      hotel_response = EXCLUDED.hotel_response,
      response_quality_score = EXCLUDED.response_quality_score,
      source_id = EXCLUDED.source_id,
      review_text = EXCLUDED.review_text,
      is_genius = EXCLUDED.is_genius,
      reservation_id = EXCLUDED.reservation_id,
      reply_last_modified = EXCLUDED.reply_last_modified,
      room_type = EXCLUDED.room_type,
      num_of_nights = EXCLUDED.num_of_nights,
      composition = EXCLUDED.composition,
      lang = EXCLUDED.lang,
      response_id = EXCLUDED.response_id
    RETURNING review_id;
  `;

  const reviewText = review.review_text || `${review.positive_review || ''} ${review.negative_review || ''}`.trim() || 'No review text provided';

  // Get or create hotel_id
  try {
    const hotel_id = await getOrCreateHotelId(
      review.hotel_name || 'Unknown',
      review.location || 'Jerusalem, Israel', // Default for Prima Palace
      review.chain_id || 1 // Default for Prima chain
    );

    // Format date as DATE (yyyy-MM-dd) or keep as TIMESTAMP
    const dateValue = review.date
      ? review.date.split('T')[0] // Extract date part
      : new Date().toISOString().split('T')[0];

    // Let response_id be generated by SERIAL
    const response_id = review.response_content ? null : null;

    const values = [
      dateValue,
      review.guest_name || 'Unknown',
      review.country || '',
      review.reviewer_rate || null,
      review.sentiment_score || null,
      review.headline || '',
      review.positive_review || '',
      review.negative_review || '',
      review.response_content || null,
      review.response_quality_score || null,
      hotel_id,
      review.source_id || 1,
      reviewText,
      review.is_genius || false,
      review.reservation_id || null,
      review.reply_last_modified || null,
      review.room_type || null,
      review.num_of_nights || null,
      review.composition || null,
      review.lang || null,
      response_id
    ];

    if (!review.response_content) {
      console.warn(`No hotel response for review by ${review.guest_name} on ${review.date}`);
    }

    console.log(`üìù Inserting review for ${review.guest_name} at ${review.hotel_name} with hotel_id: ${hotel_id}, values:`, values);
    const result = await pool.query(query, values);
    const insertedId = result.rows[0].review_id;
    console.log(`‚úÖ ${review.response_content ? 'Updated' : 'Inserted'} review with ID ${insertedId} for ${review.guest_name} on ${review.date} at hotel ${review.hotel_name}`);
    return insertedId;
  } catch (err) {
    console.error(`‚ùå Failed to insert/update review for ${review.guest_name} at ${review.hotel_name}:`, err);
    throw err;
  }
}

module.exports = { insertReview };
